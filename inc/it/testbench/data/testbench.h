#ifndef TESTBENCH_H
#define TESTBENCH_H

#include <support.h>
#incluse <testitem.h>

// $Id$
/**
 * @file testbench.h
 * This module defines the Test Bench, Test Plan and Test Case entities.
 * They are strictly related eaexch others and define a contextual runnable
 * object: the Test Cases contained in the Test Plan are treated as many
 * parallel executable jobs by the internal test bench engine.
 *
 * @brief
 *
 * @author Paolo Maresca <plo.maresca@gmail.com>
 * @version 0.1
 */
// $Log$

///  Single line comment for dOxygen.

using namespace std;

namespace it
{
namespace testbench
{
namespace data
{

/*!
* Test Bench configuration abstract Data Type.
*
* It maintains alle the needed information to automatically run the Test Plan
* (on Test Case basis) in a specialized instance of Testbench.
*/
class TestBenchConfiguration {
    public:
        TestBenchConfiguration();
        ~TestBenchConfiguration();



    private:
        string* sessionId;
        string* contextId;
        string* testPlanId;
        list<Range*> tcToBeExecuted;
        SupportedFormats format;
        int nrOfThreads;
        TestPlan* pTestPlan;
};

/*!
* It defines a Data Structure that is basically a collection of Test Cases.
*
* Each Test Case will be executed independently.
*/
class TestPlan {

};

/*!
* Abstract Data Type defining a Context Object that is used among the several
* Test Items contextually to a Test Case run.
*
* This class must be subclassed in order to contain the specific data types
* to be passed among the methods.
*/
class TestCase {
    public:
        ~TestCase();                                                            //!< it deallocates the dynamic instances
        /**
          * Initialize the data structure specific to this Test Case
          *
          * @return Boolean value, true if everythig gone well
         */
        bool setupTestCase();                                                   //!< set up a Test Case
        /**
          * Executes the Test Items specific to this Test Case
          *
          * @return Boolean value, true if everythig gone well
         */
        bool runTestCase();                                                     //!< execute a Test Case
        /**
          * Tear down the data structures initialized for this Test Case
          *
          * @return Boolean value, true if everythig gone well
         */
        bool tearDownTestCase();                                                //!< tear down a Test Case

        /**
          * Set up the specific SetupTestItem (particularized instance)
          *
          * @param[in] Pointer to a specific setup test item
         */
        void setSetupTestItem(const SetupTestItem* sTestItem);                  //!< set the Setup Test Item
        /**
          * Set up the specific TearDownTestItem (particularized instance)
          *
          * @param[in] Pointer to a specific tear down test item
         */
        void setTearDownTestItem(const TearDownTestItem* tdTestItem);           //!< set the Tear down Test Item
        /**
          * Set the Test Case Context Description
          *
          * @param[in] Pointer to a specific TestCaseContext
         */
        void setTestCaseContextObject(const TestCaseContext* tcCtxObject);      //!< set the Test Case Context Object
        /**
          * Add a specific RunnableTestItem (particularized instance)
          *
          * @param[in] Pointer to a specific runnable test item
         */
        void addRunnableTestItem(const RunnableTestItem* rTestItem);            //!< add a Runnable Test Item to the list
        /**
          * Add a report to a list of reports generated by runnable Test Items
          *
          * @param[in] Pointer to a report object
         */
        void addReport(const Report* report);                                   //!< add a Report to the list
    private:
        SetupTestItem* sTestItem;           /*!< specific test item looking after the setup */
        list<RunnableTestItem*> rTestItem;  /*!< specific test item looking after the run aspects */
        TearDownTestItem tdTestItem;        /*!< specific test item looking after the deallocation */
        list<Report*> tcReports;            /*!< list of reports (one for each runnable item */
        TestCaseContext* ctxObject;         /*!< context object: it maintanis the pointers to specific data structures to be used */
};

/*!
* Abstract Data Type defining a Test Case Builder.
*
* At run time, a concrete builder will provide the ability to build specific test cases
* based on specific Test Items: the programmer has to write only the specific source code
* for the Test Item and a specifc Test Case builder.
*
* Applying the buildre pattern strategy, the engine will be completely decoupled.
*/
class TestCaseBuilder {

};

/*!
* Its main responsibility consists in using the specific test case builders that will create
* as many specific Test Cases.
*
* This entity is very useful to decouple the caller (that wants only many Test Cases instances
* already created) from the entity delegated to concretely build the Test Cases instances.
*/
class TestCaseLoader {

};


} /* DATA */
} /* TESTBENCH */
} /* IT */

#endif /* TESTBENCH_H */
